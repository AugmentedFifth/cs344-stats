#!/usr/bin/env bash


# Get the data (whether from specified file or directly from stdin)
# into a single spot.
datapath="data$$"
clean_up_data=1 # Whether or not $datapath is the name of a temp file that
                # we need to clean up later.
if [ "$#" = "1" ];
then
    cat > "$datapath"
    clean_up_data=0 # This needs to be cleaned up.
elif [ "$#" = "2" ];
then
    datapath="$2"
else
    echo "./stats {-rows|-cols} [file]" 1>&2
    exit 1
fi


# Error handling that bails out early based on input file.
if [ ! -f $datapath ];
then
    echo "$datapath: file does not exist or is not a plain file"
    exit 1
fi

if [ ! -r $datapath ];
then
    echo "$datapath: file could not be read"
    exit 1
fi

if [ ! -s $datapath ];
then
    echo "$datapath: file is empty"
    exit 0
fi


# Decide whether to process rows or columns.
if [[ $1 == -r* ]];
then
    echo -e "Average\tMedian"

    median_temp_file="median$$" # Store numbers here as we see them to
                                # make it easier later.
    while read line
    do
        # We use a simple loop/accumulate regime to get the number of elements
        # in this row and the sum of the elements of this row, and to put the
        # row in its own file for median-obtaining purposes.
        elem_count=0
        sum=0
        for num in $line
        do
            (( elem_count++ ))
            (( sum += num ))
            echo "$num" >> "$median_temp_file"
        done

        avg=$(( (sum + elem_count / 2) / elem_count ))

        middle_index=$(( elem_count / 2 + 1 )) # 1-indexed because we're
                                               # using `head`.

        median="$(sort -n $median_temp_file | head -n$middle_index | tail -n1)"

        rm -f "$median_temp_file"

        echo -e "$avg\t$median"
    done < "$datapath"
elif [[ $1 == -c* ]];
then
    # Quickly figure out how many columns we are working with so that we can
    # loop through the relevant indices.
    col_count="$(head -n1 $datapath | wc -w)"

    # File to store each column as we `cut` it.
    col_temp_file="col_temp_file$$"

    # Files to store averages and medians for display.
    avgs_temp_file="avgs_temp_file$$"
    medians_temp_file="medians_temp_file$$"

    i=1
    while (( i <= col_count ));
    do
        cut -f "$i" "$datapath" > "$col_temp_file"

        # Now the procedure is essentially the same as with rows.
        elem_count=0
        sum=0
        while read num
        do
            (( elem_count++ ))
            (( sum += num ))
        done < "$col_temp_file"

        avg=$(( (sum + elem_count / 2) / elem_count ))
        echo -e "$avg\t\c" >> "$avgs_temp_file"

        middle_index=$(( elem_count / 2 + 1 ))

        median="$(sort -n $col_temp_file | head -n$middle_index | tail -n1)"
        echo -e "$median\t\c" >> "$medians_temp_file"

        (( i++ ))
    done

    rm -f "$col_temp_file"

    echo "Averages:"
    cat "$avgs_temp_file"
    echo ""
    echo "Medians:"
    cat "$medians_temp_file"
    echo ""

    rm -f "$avgs_temp_file"
    rm -f "$medians_temp_file"
else
    if [ "$clean_up_data" = "0" ];
    then
        rm -f "$datapath"
    fi

    echo "./stats {-rows|-cols} [file]" 1>&2
    exit 1
fi


# Clean up if necessary.
if [ "$clean_up_data" = "0" ];
then
    rm -f "$datapath"
fi

