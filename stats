#!/usr/bin/env bash


# Get the data (whether from specified file or directly from stdin)
# into a single spot.
datapath="data$$"
clean_up_data=1 # Whether or not $datapath is the name of a temp file that
                # we need to clean up later.
if [ "$#" = "1" ];
then
    cat > "$datapath"
    clean_up_data=0 # This needs to be cleaned up.
elif [ "$#" = "2" ];
then
    datapath="$2"
else
    echo "./stats {-rows|-cols} [file]" 1>&2
    exit 1
fi


# Decide whether to process rows or columns.
if [[ $1 == -r* ]];
then
    echo -e "Average\tMedian"

    median_temp_file="median$$" # Store numbers here as we see them to
                                # make it easier later.
    while read line
    do
        elem_count=0 # # of elements in this row.
        sum=0
        for num in $line
        do
            (( elem_count++ ))
            (( sum += num ))
            echo "$num" >> "$median_temp_file"
        done

        avg=$(( (sum + elem_count / 2) / elem_count ))

        middle_index=$(( elem_count / 2 + 1 )) # 1-indexed because we're
                                               # using `head`.
        #echo "[$middle_index]"
        #sort "$median_temp_file" | cat

        median="$(sort -n $median_temp_file | head -n $middle_index | tail -n 1)"

        rm -f "$median_temp_file"

        #echo "elem_count: $elem_count, sum: $sum, avg: $avg, median: $median"

        echo -e "$avg\t$median"
    done < "$datapath"
elif [[ $1 == -c* ]];
then
    echo "loopy"
else
    if [ "$clean_up_data" = "0" ];
    then
        rm -f "$datapath"
    fi

    echo "./stats {-rows|-cols} [file]" 1>&2
    exit 1
fi


# Cleanup
if [ "$clean_up_data" = "0" ];
then
    rm -f "$datapath"
fi

